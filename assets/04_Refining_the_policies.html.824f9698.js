import { e as createStaticVNode } from "./app.fb818619.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.21dcd24c.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="_4-refining-the-policies" tabindex="-1"><a class="header-anchor" href="#_4-refining-the-policies" aria-hidden="true">#</a> 4. Refining the policies</h1><ul><li><p>It is tempting to grant to the role associated to the trusted third party a policy with a wide range of permissions. However, this approach may open unwanted access to your AWS account, and thus it could be exploited with important consequences.The following are a set of tips to help you to write the minimum set of permissions policies</p></li><li><p>As developer/architect of the application, you know which components it will use: for example a S3 container, a DynamoDB, a Cloudfront service and a load balancer, So, you can add <code>s3:*</code>,<code>dynamodb:*</code>, <code>cloudfront:*</code> and <code>elasticloadbalancing:*</code></p><ul><li><p>If your application can be deployed with the previous permissions, then you can proceed to tighten them. For example, if the app is only reading from an existing table in a dynamodb you will need the <code>dynamodb:getitem</code>, <code>dynamodb:getrecords</code> actions, but your app doesnot need the <code>dynamodb:createtable</code> action. Applying these criteria repeatedly will reduce all the possible actions to a handful.</p></li><li><p>If allowed actions are not present in the policies the deployment will fail. In this case, look at the logs provided by GitHub. Usually, you will get a 400, 403 error. Sometime the logs will clearly indicate the action the code was trying to execute and that was denied.</p></li><li><p>Many actions are pretty harmless, for example <code>cloudfront:describefunction</code> does not usually have associated sensitive information while <code>cloudfront:getfunction</code> may. However, if the GitHub repo is a public one, then <code>cloudfront:getfunction</code> action does not add any security concern.</p></li><li><p>You will need to consider each action that you grant to the trusted entity in its own context.</p></li><li><p>The more open the Audience(see steps g and k),the more you need to refine the policies. The allowed policy actions for a private repo with limited access and pull request procedures may be more open than for repo that does not require PR approvals</p></li><li><p>Never create an OIDC authentication relationship between a GitHub repo and AWS with public access.</p></li></ul></li></ul><h1 id="note" tabindex="-1"><a class="header-anchor" href="#note" aria-hidden="true">#</a> Note</h1><ul><li><p>The CPF team would like to remind you of the quote: <code>The Unix philosophy basically involves giving you just enough rope to hang yourself. And then a couple of feet more, just to be sure.</code></p></li><li><p>Mistakes, errors, bugs can create havoc on your whole Cloud environment. For example, you may delete S3 buckets without noticing. Wide open permissions means that a hacker needs only access to your GitHub account to cause damage on your whole cloud environment.</p></li></ul>', 4);
function _sfc_render(_ctx, _cache) {
  return _hoisted_1;
}
var _04_Refining_the_policies_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _04_Refining_the_policies_html as default };
